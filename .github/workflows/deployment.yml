# name: Staging + Production Deploy (Need Approval)

# on:
#   pull_request:
#     branches: [ "main" ]
#   push:
#     branches: [ "main" ]
#   workflow_dispatch: {}

# permissions:
#   contents: read
#   pages: write
#   id-token: write
#   actions: write     # needed to dispatch another workflow in the same repo

# concurrency:
#   group: "pages-deploy"
#   cancel-in-progress: true

# jobs:
#   build_and_test:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - name: Upload Pages artifact (static site)
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: src

#   deploy_staging:
#     needs: build_and_test
#     runs-on: ubuntu-latest
#     environment: staging
#     outputs:
#       preview_url: ${{ steps.deploy.outputs.page_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Staging)
#         id: deploy
#         uses: actions/deploy-pages@v4

#       - name: Trigger notify-testing workflow
#         uses: actions/github-script@v7
#         env:
#           STAGING_URL: ${{ steps.deploy.outputs.page_url }}
#         with:
#           github-token: ${{ secrets.GITHUB_TOKEN }}
#           script: |
#             const ref = context.ref.replace('refs/heads/', '');
#             await github.rest.actions.createWorkflowDispatch({
#               owner: context.repo.owner,
#               repo: context.repo.repo,
#               workflow_id: 'notify-testing.yml',
#               ref,
#               inputs: { staging_url: process.env.STAGING_URL }
#             });

#   approve_and_deploy_prod:
#     needs: deploy_staging
#     runs-on: ubuntu-latest
#     environment:
#       name: production
#       url: ${{ needs.deploy_staging.outputs.preview_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Production)
#         uses: actions/deploy-pages@v4


# name: Staging + Production Deploy (gated by remote tests via repository_dispatch)

# on:
#   pull_request:
#     branches: [ "main" ]
#   push:
#     branches: [ "main" ]
#   workflow_dispatch: {}

# permissions:
#   contents: read
#   pages: write
#   id-token: write
#   actions: write

# concurrency:
#   group: "pages-deploy"
#   cancel-in-progress: true

# jobs:
#   # 0) Gate: run tests in testing repo and WAIT for result
#   remote_tests:
#     name: Run tests in testing repo and wait
#     runs-on: ubuntu-latest
#     steps:
#       - name: Send repository_dispatch to testing repo
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"  # testing repo
#           CALC_URL: "https://jmiguelcheq.github.io/calculator-demo"
#         with:
#           # PAT secret with scopes: repo, workflow (must have access to testing repo)
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO, CALC_URL } = process.env;
#             const ref = context.ref.replace('refs/heads/', '');
#             const payload = {
#               calc_url: CALC_URL,
#               source_repo: `${context.repo.owner}/${context.repo.repo}`,
#               sha: context.sha,
#               ref
#             };
#             await github.rest.repos.createDispatchEvent({
#               owner: TARGET_OWNER,
#               repo: TARGET_REPO,
#               event_type: 'run-tests',
#               client_payload: payload
#             });
#             core.info(`repository_dispatch sent to ${TARGET_OWNER}/${TARGET_REPO} with payload: ${JSON.stringify(payload)}`);

#       - name: Wait for testing repo run to complete
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"
#         with:
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO } = process.env;
#             const workflow_id = 'on-dispatch-tests.yml';   // file name in testing repo
#             const deadline = Date.now() + 20 * 60 * 1000;  // 20 min timeout

#             // Find the newest run for repository_dispatch
#             let runId = null;
#             while (Date.now() < deadline) {
#               const runs = await github.rest.actions.listWorkflowRuns({
#                 owner: TARGET_OWNER,
#                 repo: TARGET_REPO,
#                 workflow_id,
#                 event: 'repository_dispatch',
#                 per_page: 10
#               });
#               if (runs.data.total_count > 0) {
#                 runId = runs.data.workflow_runs[0].id; // most recent
#                 core.info(`Found testing run id: ${runId}`);
#                 break;
#               }
#               await new Promise(r => setTimeout(r, 5000));
#             }
#             if (!runId) core.setFailed('Could not find dispatched testing workflow run.');

#             // Poll until completed
#             while (Date.now() < deadline) {
#               const { data: run } = await github.rest.actions.getWorkflowRun({
#                 owner: TARGET_OWNER, repo: TARGET_REPO, run_id: runId
#               });
#               core.info(`Testing run status=${run.status}, conclusion=${run.conclusion}`);
#               if (run.status === 'completed') {
#                 if (run.conclusion !== 'success') {
#                   core.setFailed(`Remote tests failed: ${run.conclusion}`);
#                 }
#                 break;
#               }
#               await new Promise(r => setTimeout(r, 10000));
#             }

#   # 1) Package site (only if remote tests succeeded)
#   package_site:
#     needs: remote_tests
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       # (add build steps if your site is generated)
#       - name: Upload Pages artifact (static site)
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: src  # your static folder

#   # 2) Deploy to staging
#   deploy_staging:
#     needs: package_site
#     runs-on: ubuntu-latest
#     environment: staging
#     outputs:
#       preview_url: ${{ steps.deploy.outputs.page_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Staging)
#         id: deploy
#         uses: actions/deploy-pages@v4

#   # 3) Manual approval gate, then promote same artifact to prod
#   approve_and_deploy_prod:
#     needs: deploy_staging
#     runs-on: ubuntu-latest
#     environment:
#       name: production        # add approvers in Settings → Environments → production
#       url: ${{ needs.deploy_staging.outputs.preview_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Production)
#         uses: actions/deploy-pages@v4

name: Staging + Production Deploy (gated by remote tests via repository_dispatch)

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: read
  pages: write
  id-token: write
  actions: write

concurrency:
  group: "pages-deploy"
  cancel-in-progress: true

jobs:
  # 0) Gate: run tests in testing repo and WAIT for the matching run to finish
  remote_tests:
    name: Run tests in testing repo and wait
    runs-on: ubuntu-latest
    steps:
      - name: Send repository_dispatch to testing repo
        id: send_remote_tests
        uses: actions/github-script@v7
        env:
          TARGET_OWNER: "jmiguelcheq"
          TARGET_REPO: "calculator-test-demo"  # testing repo
          CALC_URL: "https://jmiguelcheq.github.io/calculator-demo"
        with:
          # PAT secret with scopes: repo, workflow (must have access to testing repo)
          github-token: ${{ secrets.CI_PAT }}
          script: |
            const { TARGET_OWNER, TARGET_REPO, CALC_URL } = process.env;
            const ref = context.ref.replace('refs/heads/', ''); // e.g., "main"

            // Record the time right before we dispatch so we can ignore older runs
            const dispatchedAt = new Date().toISOString();

            const payload = {
              calc_url: CALC_URL,
              source_repo: `${context.repo.owner}/${context.repo.repo}`,
              sha: context.sha,
              ref
            };

            await github.rest.repos.createDispatchEvent({
              owner: TARGET_OWNER,
              repo: TARGET_REPO,
              event_type: 'run-tests',
              client_payload: payload
            });

            core.info(`repository_dispatch sent to ${TARGET_OWNER}/${TARGET_REPO} with payload: ${JSON.stringify(payload)}`);
            core.setOutput('dispatched_at', dispatchedAt);

      - name: Wait for testing repo run to complete
        uses: actions/github-script@v7
        env:
          TARGET_OWNER: "jmiguelcheq"
          TARGET_REPO: "calculator-test-demo"
          DISPATCHED_AT: ${{ steps.send_remote_tests.outputs.dispatched_at }}
        with:
          github-token: ${{ secrets.CI_PAT }}
          script: |
            const { TARGET_OWNER, TARGET_REPO, DISPATCHED_AT } = process.env;
            const workflow_id = 'on-dispatch-tests.yml'; // file name in testing repo
            const deadline = Date.now() + 20 * 60 * 1000; // 20 minutes
            const dispatchedAtMs = Date.parse(DISPATCHED_AT);

            // Find the first repository_dispatch run created AFTER we dispatched
            let runId = null;
            while (Date.now() < deadline) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: TARGET_OWNER,
                repo: TARGET_REPO,
                workflow_id,
                event: 'repository_dispatch',
                per_page: 20
              });

              const candidate = runs.data.workflow_runs.find(r =>
                r.event === 'repository_dispatch' &&
                Date.parse(r.created_at) >= dispatchedAtMs
              );

              if (candidate) {
                runId = candidate.id;
                core.info(`Matched testing run id: ${runId} (created_at=${candidate.created_at})`);
                break;
              }

              await new Promise(r => setTimeout(r, 5000));
            }

            if (!runId) core.setFailed('Could not find the dispatched testing workflow run.');

            // Poll until the matched run completes
            while (Date.now() < deadline) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: TARGET_OWNER, repo: TARGET_REPO, run_id: runId
              });
              core.info(`Testing run status=${run.status}, conclusion=${run.conclusion}`);
              if (run.status === 'completed') {
                if (run.conclusion !== 'success') {
                  core.setFailed(`Remote tests failed: ${run.conclusion}`);
                }
                break;
              }
              await new Promise(r => setTimeout(r, 10000));
            }

  # 1) Package site (only if remote tests succeeded)
  package_site:
    needs: remote_tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # (add build steps here if your site is generated)
      - name: Upload Pages artifact (static site)
        uses: actions/upload-pages-artifact@v3
        with:
          path: src  # your static folder

  # 2) Deploy to staging
  deploy_staging:
    needs: package_site
    runs-on: ubuntu-latest
    environment: staging
    outputs:
      preview_url: ${{ steps.deploy.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages (Staging)
        id: deploy
        uses: actions/deploy-pages@v4

  # 3) Manual approval gate, then promote same artifact to prod
  approve_and_deploy_prod:
    needs: deploy_staging
    runs-on: ubuntu-latest
    environment:
      name: production        # add approvers in Settings → Environments → production
      url: ${{ needs.deploy_staging.outputs.preview_url }}
    steps:
      - name: Deploy to GitHub Pages (Production)
        uses: actions/deploy-pages@v4
