# name: Staging + Production Deploy (Need Approval)

# on:
#   pull_request:
#     branches: [ "main" ]
#   push:
#     branches: [ "main" ]
#   workflow_dispatch: {}

# permissions:
#   contents: read
#   pages: write
#   id-token: write
#   actions: write     # needed to dispatch another workflow in the same repo

# concurrency:
#   group: "pages-deploy"
#   cancel-in-progress: true

# jobs:
#   build_and_test:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - name: Upload Pages artifact (static site)
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: src

#   deploy_staging:
#     needs: build_and_test
#     runs-on: ubuntu-latest
#     environment: staging
#     outputs:
#       preview_url: ${{ steps.deploy.outputs.page_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Staging)
#         id: deploy
#         uses: actions/deploy-pages@v4

#       - name: Trigger notify-testing workflow
#         uses: actions/github-script@v7
#         env:
#           STAGING_URL: ${{ steps.deploy.outputs.page_url }}
#         with:
#           github-token: ${{ secrets.GITHUB_TOKEN }}
#           script: |
#             const ref = context.ref.replace('refs/heads/', '');
#             await github.rest.actions.createWorkflowDispatch({
#               owner: context.repo.owner,
#               repo: context.repo.repo,
#               workflow_id: 'notify-testing.yml',
#               ref,
#               inputs: { staging_url: process.env.STAGING_URL }
#             });

#   approve_and_deploy_prod:
#     needs: deploy_staging
#     runs-on: ubuntu-latest
#     environment:
#       name: production
#       url: ${{ needs.deploy_staging.outputs.preview_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Production)
#         uses: actions/deploy-pages@v4


# name: Staging + Production Deploy (gated by remote tests via repository_dispatch)

# on:
#   pull_request:
#     branches: [ "main" ]
#   push:
#     branches: [ "main" ]
#   workflow_dispatch: {}

# permissions:
#   contents: read
#   pages: write
#   id-token: write
#   actions: write

# concurrency:
#   group: "pages-deploy"
#   cancel-in-progress: true

# jobs:
#   # 0) Gate: run tests in testing repo and WAIT for result
#   remote_tests:
#     name: Run tests in testing repo and wait
#     runs-on: ubuntu-latest
#     steps:
#       - name: Send repository_dispatch to testing repo
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"  # testing repo
#           CALC_URL: "https://jmiguelcheq.github.io/calculator-demo"
#         with:
#           # PAT secret with scopes: repo, workflow (must have access to testing repo)
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO, CALC_URL } = process.env;
#             const ref = context.ref.replace('refs/heads/', '');
#             const payload = {
#               calc_url: CALC_URL,
#               source_repo: `${context.repo.owner}/${context.repo.repo}`,
#               sha: context.sha,
#               ref
#             };
#             await github.rest.repos.createDispatchEvent({
#               owner: TARGET_OWNER,
#               repo: TARGET_REPO,
#               event_type: 'run-tests',
#               client_payload: payload
#             });
#             core.info(`repository_dispatch sent to ${TARGET_OWNER}/${TARGET_REPO} with payload: ${JSON.stringify(payload)}`);

#       - name: Wait for testing repo run to complete
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"
#         with:
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO } = process.env;
#             const workflow_id = 'on-dispatch-tests.yml';   // file name in testing repo
#             const deadline = Date.now() + 20 * 60 * 1000;  // 20 min timeout

#             // Find the newest run for repository_dispatch
#             let runId = null;
#             while (Date.now() < deadline) {
#               const runs = await github.rest.actions.listWorkflowRuns({
#                 owner: TARGET_OWNER,
#                 repo: TARGET_REPO,
#                 workflow_id,
#                 event: 'repository_dispatch',
#                 per_page: 10
#               });
#               if (runs.data.total_count > 0) {
#                 runId = runs.data.workflow_runs[0].id; // most recent
#                 core.info(`Found testing run id: ${runId}`);
#                 break;
#               }
#               await new Promise(r => setTimeout(r, 5000));
#             }
#             if (!runId) core.setFailed('Could not find dispatched testing workflow run.');

#             // Poll until completed
#             while (Date.now() < deadline) {
#               const { data: run } = await github.rest.actions.getWorkflowRun({
#                 owner: TARGET_OWNER, repo: TARGET_REPO, run_id: runId
#               });
#               core.info(`Testing run status=${run.status}, conclusion=${run.conclusion}`);
#               if (run.status === 'completed') {
#                 if (run.conclusion !== 'success') {
#                   core.setFailed(`Remote tests failed: ${run.conclusion}`);
#                 }
#                 break;
#               }
#               await new Promise(r => setTimeout(r, 10000));
#             }

#   # 1) Package site (only if remote tests succeeded)
#   package_site:
#     needs: remote_tests
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       # (add build steps if your site is generated)
#       - name: Upload Pages artifact (static site)
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: src  # your static folder

#   # 2) Deploy to staging
#   deploy_staging:
#     needs: package_site
#     runs-on: ubuntu-latest
#     environment: staging
#     outputs:
#       preview_url: ${{ steps.deploy.outputs.page_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Staging)
#         id: deploy
#         uses: actions/deploy-pages@v4

#   # 3) Manual approval gate, then promote same artifact to prod
#   approve_and_deploy_prod:
#     needs: deploy_staging
#     runs-on: ubuntu-latest
#     environment:
#       name: production        # add approvers in Settings → Environments → production
#       url: ${{ needs.deploy_staging.outputs.preview_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Production)
#         uses: actions/deploy-pages@v4

# name: Staging + Production Deploy (gated by remote tests via repository_dispatch)

# on:
#   pull_request:
#     branches: [ "main" ]
#   push:
#     branches: [ "main" ]
#   workflow_dispatch: {}

# permissions:
#   contents: read
#   pages: write
#   id-token: write
#   actions: write

# concurrency:
#   group: "pages-deploy"
#   cancel-in-progress: true

# jobs:
#   # 0) Gate: run tests in testing repo and WAIT for the matching run to finish
#   remote_tests:
#     name: Run tests in testing repo and wait
#     runs-on: ubuntu-latest
#     steps:
#       - name: Send repository_dispatch to testing repo
#         id: send_remote_tests
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"  # testing repo
#           CALC_URL: "https://jmiguelcheq.github.io/calculator-demo"
#         with:
#           # PAT secret with scopes: repo, workflow (must have access to testing repo)
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO, CALC_URL } = process.env;
#             const ref = context.ref.replace('refs/heads/', ''); // e.g., "main"

#             // Record the time right before we dispatch so we can ignore older runs
#             const dispatchedAt = new Date().toISOString();

#             const payload = {
#               calc_url: CALC_URL,
#               source_repo: `${context.repo.owner}/${context.repo.repo}`,
#               sha: context.sha,
#               ref
#             };

#             await github.rest.repos.createDispatchEvent({
#               owner: TARGET_OWNER,
#               repo: TARGET_REPO,
#               event_type: 'run-tests',
#               client_payload: payload
#             });

#             core.info(`repository_dispatch sent to ${TARGET_OWNER}/${TARGET_REPO} with payload: ${JSON.stringify(payload)}`);
#             core.setOutput('dispatched_at', dispatchedAt);

#       - name: Wait for testing repo run to complete
#         uses: actions/github-script@v7
#         env:
#           TARGET_OWNER: "jmiguelcheq"
#           TARGET_REPO: "calculator-test-demo"
#           DISPATCHED_AT: ${{ steps.send_remote_tests.outputs.dispatched_at }}
#         with:
#           github-token: ${{ secrets.CI_PAT }}
#           script: |
#             const { TARGET_OWNER, TARGET_REPO, DISPATCHED_AT } = process.env;
#             const workflow_id = 'on-dispatch-tests.yml'; // file name in testing repo
#             const deadline = Date.now() + 20 * 60 * 1000; // 20 minutes
#             const dispatchedAtMs = Date.parse(DISPATCHED_AT);

#             // Find the first repository_dispatch run created AFTER we dispatched
#             let runId = null;
#             while (Date.now() < deadline) {
#               const runs = await github.rest.actions.listWorkflowRuns({
#                 owner: TARGET_OWNER,
#                 repo: TARGET_REPO,
#                 workflow_id,
#                 event: 'repository_dispatch',
#                 per_page: 20
#               });

#               const candidate = runs.data.workflow_runs.find(r =>
#                 r.event === 'repository_dispatch' &&
#                 Date.parse(r.created_at) >= dispatchedAtMs
#               );

#               if (candidate) {
#                 runId = candidate.id;
#                 core.info(`Matched testing run id: ${runId} (created_at=${candidate.created_at})`);
#                 break;
#               }

#               await new Promise(r => setTimeout(r, 5000));
#             }

#             if (!runId) core.setFailed('Could not find the dispatched testing workflow run.');

#             // Poll until the matched run completes
#             while (Date.now() < deadline) {
#               const { data: run } = await github.rest.actions.getWorkflowRun({
#                 owner: TARGET_OWNER, repo: TARGET_REPO, run_id: runId
#               });
#               core.info(`Testing run status=${run.status}, conclusion=${run.conclusion}`);
#               if (run.status === 'completed') {
#                 if (run.conclusion !== 'success') {
#                   core.setFailed(`Remote tests failed: ${run.conclusion}`);
#                 }
#                 break;
#               }
#               await new Promise(r => setTimeout(r, 10000));
#             }

#   # 1) Package site (only if remote tests succeeded)
#   package_site:
#     needs: remote_tests
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       # (add build steps here if your site is generated)
#       - name: Upload Pages artifact (static site)
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: src  # your static folder

#   # 2) Deploy to staging
#   deploy_staging:
#     needs: package_site
#     runs-on: ubuntu-latest
#     environment: staging
#     outputs:
#       preview_url: ${{ steps.deploy.outputs.page_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Staging)
#         id: deploy
#         uses: actions/deploy-pages@v4

#   # 3) Manual approval gate, then promote same artifact to prod
#   approve_and_deploy_prod:
#     needs: deploy_staging
#     runs-on: ubuntu-latest
#     environment:
#       name: production        # add approvers in Settings → Environments → production
#       url: ${{ needs.deploy_staging.outputs.preview_url }}
#     steps:
#       - name: Deploy to GitHub Pages (Production)
#         uses: actions/deploy-pages@v4


name: Staging + Production Deploy (gated by remote tests via repository_dispatch)

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: read
  pages: write
  id-token: write
  actions: write
  pull-requests: write   # needed to comment on PRs
  statuses: write        # needed to set commit status

concurrency:
  group: "pages-deploy"
  cancel-in-progress: true

jobs:
  # 0) Gate: run tests in testing repo and WAIT for the matching run to finish
  remote_tests:
    name: Run tests in testing repo and wait
    runs-on: ubuntu-latest
    steps:
      - name: Send repository_dispatch to testing repo
        id: send_remote_tests
        uses: actions/github-script@v7
        env:
          TARGET_OWNER: "jmiguelcheq"
          TARGET_REPO: "calculator-test-demo"  # testing repo
          CALC_URL: "https://jmiguelcheq.github.io/calculator-demo"
        with:
          # PAT secret with scopes: repo, workflow (must have access to testing repo)
          github-token: ${{ secrets.CI_PAT }}
          script: |
            const { TARGET_OWNER, TARGET_REPO, CALC_URL } = process.env;
            const ref = context.ref.replace('refs/heads/', ''); // e.g., "main"

            // Record the time right before we dispatch so we can ignore older runs
            const dispatchedAt = new Date().toISOString();

            const payload = {
              calc_url: CALC_URL,
              source_repo: `${context.repo.owner}/${context.repo.repo}`,
              sha: context.sha,
              ref
            };

            await github.rest.repos.createDispatchEvent({
              owner: TARGET_OWNER,
              repo: TARGET_REPO,
              event_type: 'run-tests',
              client_payload: payload
            });

            core.info(`repository_dispatch sent to ${TARGET_OWNER}/${TARGET_REPO} with payload: ${JSON.stringify(payload)}`);
            core.setOutput('dispatched_at', dispatchedAt);

      - name: Wait for testing repo run to complete
        id: wait_remote_tests
        uses: actions/github-script@v7
        env:
          TARGET_OWNER: "jmiguelcheq"
          TARGET_REPO: "calculator-test-demo"
          DISPATCHED_AT: ${{ steps.send_remote_tests.outputs.dispatched_at }}
        with:
          github-token: ${{ secrets.CI_PAT }}
          script: |
            const { TARGET_OWNER, TARGET_REPO, DISPATCHED_AT } = process.env;
            const workflow_id = 'on-dispatch-tests.yml'; // file name in testing repo
            const deadline = Date.now() + 20 * 60 * 1000; // 20 minutes
            const dispatchedAtMs = Date.parse(DISPATCHED_AT);

            // Find the first repository_dispatch run created AFTER we dispatched
            let runId = null;
            let matched = null;
            while (Date.now() < deadline) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: TARGET_OWNER,
                repo: TARGET_REPO,
                workflow_id,
                event: 'repository_dispatch',
                per_page: 20
              });

              matched = runs.data.workflow_runs.find(r =>
                r.event === 'repository_dispatch' &&
                Date.parse(r.created_at) >= dispatchedAtMs
              );

              if (matched) {
                runId = matched.id;
                core.info(`Matched testing run id: ${runId} (created_at=${matched.created_at})`);
                break;
              }

              await new Promise(r => setTimeout(r, 5000));
            }

            if (!runId) core.setFailed('Could not find the dispatched testing workflow run.');

            // Poll until the matched run completes
            let run;
            while (Date.now() < deadline) {
              const res = await github.rest.actions.getWorkflowRun({
                owner: TARGET_OWNER, repo: TARGET_REPO, run_id: runId
              });
              run = res.data;
              core.info(`Testing run status=${run.status}, conclusion=${run.conclusion}`);
              if (run.status === 'completed') break;
              await new Promise(r => setTimeout(r, 10000));
            }

            if (!run) core.setFailed('No run detail fetched.');

            core.setOutput('run_url', run.html_url);
            core.setOutput('conclusion', run.conclusion || 'unknown');

            if (run.conclusion !== 'success') {
              core.setFailed(`Remote tests failed: ${run.conclusion}`);
            }

      # Surface result in PR checks (always runs)
      - name: Set commit status (Remote UI Tests)
        if: ${{ always() }}
        uses: actions/github-script@v7
        env:
          RUN_URL: ${{ steps.wait_remote_tests.outputs.run_url }}
          CONCLUSION: ${{ steps.wait_remote_tests.outputs.conclusion }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const state = (process.env.CONCLUSION === 'success') ? 'success' : 'failure';
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state,
              context: 'Remote UI Tests',
              target_url: process.env.RUN_URL || undefined,
              description: (state === 'success') ? 'Remote tests passed' : 'Remote tests failed'
            });

      # Friendly PR comment with link when tests fail
      - name: Comment on PR when tests fail
        if: ${{ steps.wait_remote_tests.outputs.conclusion != 'success' }}
        uses: actions/github-script@v7
        env:
          RUN_URL: ${{ steps.wait_remote_tests.outputs.run_url }}
          CONCLUSION: ${{ steps.wait_remote_tests.outputs.conclusion }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runUrl = process.env.RUN_URL;
            const conclusion = process.env.CONCLUSION || 'failure';
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Find the PR to comment on (works for push or PR events)
            let prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: context.sha
              });
              if (prs.data.length) prNumber = prs.data[0].number;
            }

            if (!prNumber) {
              core.info('No PR found to comment on; skipping PR comment.');
            } else {
              const body = [
                `🚨 **Automation tests failed** for this change.`,
                ``,
                `Please review the report and logs: ${runUrl}`,
                ``,
                `> Conclusion: **${conclusion.toUpperCase()}**`
              ].join('\n');

              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
              core.info(`Comment posted to PR #${prNumber}`);
            }

  # 1) Package site (only if remote tests succeeded)
  package_site:
    needs: remote_tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    steps:
      - uses: actions/checkout@v4
      # (add build steps here if your site is generated)
      - name: Upload Pages artifact (static site)
        uses: actions/upload-pages-artifact@v3
        with:
          path: src  # your static folder

  # 2) Deploy to staging
  deploy_staging:
    needs: package_site
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    environment: staging
    outputs:
      preview_url: ${{ steps.deploy.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages (Staging)
        id: deploy
        uses: actions/deploy-pages@v4

  # 3) Manual approval gate, then promote same artifact to prod
  approve_and_deploy_prod:
    needs: deploy_staging
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    environment:
      name: production        # add approvers in Settings → Environments → production
      url: ${{ needs.deploy_staging.outputs.preview_url }}
    steps:
      - name: Deploy to GitHub Pages (Production)
        uses: actions/deploy-pages@v4
